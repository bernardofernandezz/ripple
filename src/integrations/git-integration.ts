import { simpleGit, SimpleGit } from 'simple-git';
import * as vscode from 'vscode';
import { DependencyGraphManager } from '../analysis/dependency-graph';
import { ImpactAnalyzer } from '../analysis/impact-analyzer';

export interface BranchImpactReport {
    branch: string;
    base: string;
    totalFilesChanged: number;
    totalImpactedFiles: number;
    riskScore: number;
    impacts: FileImpact[];
    breakingChangeCount: number;
}

export interface FileImpact {
    file: string;
    dependentCount: number;
    hasBreakingChanges: boolean;
    breakingChangeCount: number;
    testCoverage?: number;
}

export class GitIntegration {
    private git: SimpleGit;
    private graphManager: DependencyGraphManager;
    private impactAnalyzer: ImpactAnalyzer;

    constructor(workspaceRoot: string, graphManager: DependencyGraphManager) {
        this.git = simpleGit(workspaceRoot);
        this.graphManager = graphManager;
        this.impactAnalyzer = new ImpactAnalyzer();
    }

    public async analyzeCurrentBranch(): Promise<BranchImpactReport> {
        try {
            const currentBranch = await this.git.revparse(['--abbrev-ref', 'HEAD']);
            const baseBranch = await this.getBaseBranch();

            const changedFiles = await this.getChangedFiles(baseBranch, currentBranch);

            const impacts: FileImpact[] = [];

            for (const file of changedFiles) {
                const fileImpact = await this.analyzeFileChanges(file);
                impacts.push(fileImpact);
            }

            return {
                branch: currentBranch,
                base: baseBranch,
                totalFilesChanged: changedFiles.length,
                totalImpactedFiles: this.calculateTotalImpact(impacts),
                riskScore: this.calculateBranchRiskScore(impacts),
                impacts,
                breakingChangeCount: impacts.filter(i => i.hasBreakingChanges).length
            };
        } catch (error) {
            console.error('Error analyzing branch:', error);
            throw error;
        }
    }

    public async generatePRComment(): Promise<string> {
        const report = await this.analyzeCurrentBranch();

        return `
## ðŸŒŠ Ripple Impact Analysis

**Branch:** \`${report.branch}\`  
**Risk Level:** ${this.getRiskBadge(report.riskScore)}

### ðŸ“Š Summary

- **Files Changed:** ${report.totalFilesChanged}
- **Files Impacted:** ${report.totalImpactedFiles}
- **Risk Score:** ${report.riskScore}/100

### âš ï¸ Breaking Changes

${report.impacts
    .filter(i => i.hasBreakingChanges)
    .map(i => `- \`${i.file}\`: ${i.breakingChangeCount} breaking changes`)
    .join('\n') || 'None detected'}

### ðŸŽ¯ Most Impacted Files

${report.impacts
    .sort((a, b) => b.dependentCount - a.dependentCount)
    .slice(0, 5)
    .map((i, idx) => `${idx + 1}. \`${i.file}\` - ${i.dependentCount} dependents`)
    .join('\n')}

### ðŸ’¡ Recommendations

${this.generateRecommendations(report)}

---

*Generated by [Ripple](https://github.com/your-org/ripple)*
`;
    }

    private async getBaseBranch(): Promise<string> {
        try {
            const branches = await this.git.branchLocal();
            if (branches.all.includes('main')) return 'main';
            if (branches.all.includes('master')) return 'master';
            return 'main';
        } catch {
            return 'main';
        }
    }

    private async getChangedFiles(base: string, current: string): Promise<string[]> {
        try {
            const diff = await this.git.diffSummary([`${base}...${current}`]);
            return diff.files
                .filter(f => f.file.endsWith('.ts') || f.file.endsWith('.tsx') || 
                            f.file.endsWith('.js') || f.file.endsWith('.jsx'))
                .map(f => f.file);
        } catch (error) {
            console.error('Error getting changed files:', error);
            return [];
        }
    }

    private async analyzeFileChanges(file: string): Promise<FileImpact> {
        // Get dependents from graph
        const graph = this.graphManager.getGraph();
        const fileSymbols = graph.getAllNodes().filter(
            s => s.location.file === file
        );

        let totalDependents = 0;
        let breakingChangeCount = 0;

        for (const symbol of fileSymbols) {
            const dependents = this.graphManager.getDependents(symbol);
            totalDependents += dependents.length;

            // Check for breaking changes (simplified)
            const edges = graph.getEdgesForSymbol(symbol);
            breakingChangeCount += edges.length; // Simplified check
        }

        return {
            file,
            dependentCount: totalDependents,
            hasBreakingChanges: breakingChangeCount > 0,
            breakingChangeCount
        };
    }

    private calculateTotalImpact(impacts: FileImpact[]): number {
        const uniqueFiles = new Set<string>();
        impacts.forEach(impact => {
            // This would need to query the graph for actual impacted files
            uniqueFiles.add(impact.file);
        });
        return uniqueFiles.size;
    }

    private calculateBranchRiskScore(impacts: FileImpact[]): number {
        let score = 0;

        // Breaking changes contribute heavily
        const breakingCount = impacts.filter(i => i.hasBreakingChanges).length;
        score += Math.min(breakingCount * 15, 50);

        // High dependent counts contribute
        const avgDependents = impacts.reduce((sum, i) => sum + i.dependentCount, 0) / impacts.length;
        score += Math.min(avgDependents * 2, 30);

        // Number of files changed
        score += Math.min(impacts.length * 2, 20);

        return Math.min(Math.round(score), 100);
    }

    private getRiskBadge(score: number): string {
        if (score <= 30) return 'ðŸŸ¢ LOW';
        if (score <= 60) return 'ðŸŸ¡ MODERATE';
        if (score <= 85) return 'ðŸŸ  HIGH';
        return 'ðŸ”´ CRITICAL';
    }

    private generateRecommendations(report: BranchImpactReport): string {
        const recommendations: string[] = [];

        if (report.riskScore > 70) {
            recommendations.push('âš ï¸ **High-risk changes.** Consider breaking into smaller PRs.');
        }

        if (report.breakingChangeCount > 0 && report.totalFilesChanged > 10) {
            recommendations.push('ðŸ§ª **Add more tests** for files with breaking changes.');
        }

        if (report.totalImpactedFiles > 50) {
            recommendations.push('ðŸ“ **Create migration guide** for other developers.');
        }

        return recommendations.length > 0
            ? recommendations.map(r => `- ${r}`).join('\n')
            : 'âœ… Changes look good! No major concerns.';
    }
}

